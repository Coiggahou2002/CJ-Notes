# 七牛云 | 头像上传

## 存储方案

使用七牛云对象存储来放用户头像文件，命名格式为 `avatar_${account}`，其中 `${account}` 为用户在后台的唯一账户名.

> 项目的所有文件放在对象存储的同一个 bucket 中，通过加前缀来区分不同业务的文件.

## 前后端逻辑

前端负责：头像上传的交互、图片校验和裁剪、七牛云上传

后端负责：生成上传凭证、将新头像 URL 写入数据库

整体逻辑如下：

+ 用户上传头像时，进行文件格式和大小的校验（只允许不超过 2 MB 的 jpeg 或 png）
+ 用户通过裁剪框对头像进行裁剪（裁剪控件统一输出 jpeg）
+ 前端通过全局状态获取用户名 account，生成文件名 `avatar_${account}` 作为上传的  `key`
+ 前端向后端发送包含 `key` 的上传请求，后端根据 `bucket` 和 `key` 以及七牛云的 `AccessKey` 和 `SecretKey`（除了 `key` 外，其他参数都在后端配置）生成上传用的 token 并发送给前端
+ 前端使用该 token 向七牛云 COS 发送上传裁剪后图像文件的请求（图像使用 Blob 格式，以便能被七牛云 COS 识别为正确的 image/jpeg 类型）
+ 上传成功，七牛云发回包含所上传文件的 `hash` 和 `key` 的响应；上传失败则中断并提示用户重来
+ 前端将七牛云外链域名和 `key` 拼接成新头像 URL `http://xxx.cn/${key}`，将此 URL 发送给后端，要求后端写入数据库
+ 后端操作成功后返回自定义成功响应码，此时前端提示用户“上传成功”
+ 前端刷新用户信息，重新从后台拉取包含头像的用户信息，以便用户能看到新头像

> 如果用户想修改头像，就再执行一遍上述操作，上传的文件同名，七牛云会自动覆盖

## 缓存问题

上述整体逻辑完成之后，出现了一个不可控的小问题：

当用户想修改头像时，成功上传了一个新图片，覆盖掉了七牛云上原来的头像文件（同一个用户的头像命名是一样的，同名就会覆盖），但是，在覆盖上传后的相当长一段时间内，访问图片外链 `http://xxx.cn/avatar_${account}` 还是会获取到原来的图片.

查询七牛云官方文档得知，以上问题是缓存导致的：

> 访问资源链接时，缓存通常分为浏览器缓存和 CDN 节点缓存.
>
> 用户在浏览器中输入资源链接访问时，优先使用浏览器缓存，缓存失效或禁用本地缓存后，会向 CDN 节点请求资源，当 CDN 缓存时间超时后，会向源站发起资源请求.
>
> + Cache-Control:max-age: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)，控制用户浏览器端的缓存.
> + CDN 缓存：当 CDN 缓存超时后，节点认为缓存失效，会向源站重新请求资源.
>

要解决这个问题，经过查找之后，有以下几种解决方案：

（参考 [刷新缓存的方法 - 七牛云开发者中心](https://developer.qiniu.com/fusion/kb/1325/refresh-the-cache-and-the-effect-of-time)）

**1.缩短浏览器对该外链资源的缓存时间**

浏览器在请求七牛云的资源时，七牛云可以在发回的响应头中设置 `Cache-Control: maxAge=xxx` 来告诉浏览器该资源缓存多长时间就过期.

七牛云 COS 的控制台可以设置 `maxAge` 的秒数，默认值为 31536000 秒（即 365 天），可以将其缩短.

（但除非把 maxAge 缩到很短很短，否则这个方案并不会对头像上传缓存问题起什么作用，而且也没必要这么改）

**2.把 CDN 的缓存时间调短**

作用于所有存储的文件，不太有必要，而且会增大回源流量导致费用增加

**3.每次更新头像时用新的文件名，然后删掉旧文件**

有点麻烦，目前还是希望头像的 `key` 是固定的，而不是总要变化

**4.仍然使用覆盖上传，但每次覆盖后手动调用缓存刷新接口**

没有尝试过，但应该是可行的办法

**5.覆盖上传 + 携带随机 URL 参数刷新**

![](https://cjpark-1304138896.cos.ap-guangzhou.myqcloud.com/note_img/qiniu.png)

根据七牛云官方文档所述，七牛云支持通过在外链后附加形如 `?v=123456` 的版本字符串来达到强制其回源站取文件的目的，要求是每次用的版本号都不一样，如第一次用了 `?v=1`，下一次再访问希望刷新就不能再用 `?v=1`，而应该使用没用过的版本号，不过这个很好解决，每次更新头像都获取一次 Unix 时间戳作为版本号就可以了.

该方案通过在 URL 后加参数就可以强制刷新指定 URL 的某一个资源，且没有前面那些方法的副作用，是目前看来最好的解决方案.

所以，最终使用了方案 5 解决缓存的问题，目前已经调试完成，效果良好.
