# TCP 协议

```python
# Python中创建TCP套接字的方法
tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

一个 TCP socket 由一个四元组标识

$$(sourceIP,sourcePort,destIP,destPort)$$

## 主要特点

1. 面向连接的传输层协议
2. 每条 TCP 连接是点对点的
3. 提供可靠数据传输服务
4. 全双工通信
5. 面向字节流

##  可靠数据传输原理

现在让我们来想象一个场景，有一条大河将分别处于两岸的 A 村和 B 村隔开，导致 A 村与 B 村之间只能通过船只来传递货物，这两条村各在岸边设置了一个搬运工甲、乙，负责将各自村里的商店、工厂、家庭送过来的货物递给船夫，让船夫送到河对岸去.

在该场景中：

+ A 村是发送方，B 村是接收方
+ 船夫是网络层及其下方的层的封装
+ 村里的商店、工厂、家庭等是应用层主机的进程
+ 甲、乙是运输层协议
+ 货物的损坏对应分组发生比特差错，纸条的损坏对应 ACK / NAK 分组的比特差错.
+ 船毁人亡对应丢包

下面我们用该场景来模拟各个版本的 rdt 协议 (reliable data transfer)

### rdt 1.0

**考虑最简单的模型，底层信道完全可靠，不需要确认消息，不需要重传.**

也就是说，无论风吹雨打，船夫一定能够完整且无误地将每一个包裹送达从河的一边送到另一边.

这时候的状态机很简单.

A 村的甲

+ 等待镇里的货物运过来岸边，你运过来，我就打包给船夫，让他送过去

B 村的乙

+ 我在岸边等船夫，船夫送货过来，我就收下，拆包之后送给村里对应的店

### rdt 2.0

**考虑可能发生比特差错（因此需要接收方返回 ACK 或 NAK 以确认是否需要重传），不考虑 ACK / NAK 确认包的损坏，不考虑丢包.**

也就是说，在从 A 村向 B 村运货物时，船夫一定能将包从河的一边送到另一边，但包裹可能会因为日晒雨淋而发生一定程度的破损；船夫在从 B 村回来时，会携带一个纸条而不是货物（纸条也必定能够送达），上面写着乙要对甲说的话（比如“你送过来的包裹淋湿了，用不了，请给我重传”或者“包裹已验收，没问题”）

这时候的状态如下

A 村的甲

1. 等镇里货物运过来，打包给船夫，让他送过去
2. 等船夫送纸条回来，看看乙对收到的包裹满不满意
3. 如果乙说包裹没损坏就跳到 1，等新货物，若损坏就叫船夫把同样的包再送一遍，跳到 2.

B 村的乙

1. 等对岸船夫运货物过来，检查包裹有无损坏
2. 若有损坏，写纸条“NAK”，若无损坏，写纸条“ACK”，让船夫把纸条送回去给甲看

### rdt 2.1

**考虑可能发生比特差错，考虑 ACK / NAK 包可能损坏，不考虑丢包.**

也就是说，船夫送货物或者送纸条仍然是“必定送达”的，但是加入了一个考虑——纸条也有可能遭受日晒雨淋而导致上面的字看不清，进而导致甲没办法搞清楚：乙到底需不需要甲重新发货？

这里就需要添加一点东西——甲在把镇里的包裹给船夫之前，会在包裹上写上该货物的编号，那么乙在收到货物时，只需要看看这个编号自己是否收到过，就知道甲是在重新发货还是发一个新的货物. （实际场景中作了简化，由于只需要区分到底是“上次的包裹”还是“新的包裹”，所以实际上编号只需要 0 和 1 就可以了）

状态如下：

**A 村的甲**

1. 等镇里货物运过来，写上编号 0，打包给船夫
2. 等船夫送纸条回来，如果纸条说需要重发或者纸条已经模糊不清，甲就重新发货，继续等待，直到乙传过来的纸条能看清楚并且写着“ACK”，就跳到 3
3. 等镇里货物运过来，写上编号 1，打包给船夫
4. 等船夫送纸条回来，如果纸条说需要重发或者纸条已经模糊不清，甲就重新发货，继续等待，直到乙传过来的纸条能看清楚并且写着“ACK”，就跳到 1

**B 村的乙**

1. 希望收到 0 号包裹，等船夫运货过来，检查编号，如果编号正确且无损坏，写纸条 ACK 让船夫送回去，跳到 2；否则写 NAK 让船夫送回去，继续等待
2. 希望收到 1 号包裹，等船夫运货过来，检查编号，如果编号正确且无损坏，写纸条 ACK 让船夫送回去，跳到 1；否则写 NAK 让船夫送回去，继续等待

### rdt 2.2

**考虑发生比特差错，考虑 ACK / NAK 包损坏，不考虑丢包.**

**该版本 rdt 只比上个版本做了一点点改动，即给确认消息加上编号，如 ACK(1) 和 ACK(0)，表示确认收到 1 号或 0 号的包裹，并且取消 NAK，用发送上一个包裹的 ACK 代替 NAK.**

也就是说，例如乙刚刚收到了 0 号包并且确认无损，就写纸条 ACK(0) 并让船夫送给甲，

如果纸条没有受损，甲就会看到并发送 1 号包，但是 1 号包到达乙的手上的时候已经破损，乙就写纸条 ACK(0) 让船夫送给甲；

如果纸条受损，甲就会重传 0 号包，到达乙手上的时候，乙就会发现这不是我想要的，然后就写纸条 ACK(0) 让船夫送给甲.

总而言之，在乙接受 0 号包裹出现问题的时候，就会回复 ACK(1) 来代替 NAK，接收 1 号包裹出现问题的时候，就会回复 ACK(0) 来代替 NAK.

“我成功收到了上一个”的潜台词，就是“这一个我没成功收到”

### rdt 3.0

考虑比特差错，考虑 ACK / NAK 包损坏，考虑丢包.

在该场景中来讲，考虑丢包就意味着，船夫可能在中途遭遇恶劣天气，船毁人亡.

按照常理来思考，我们回想，两条大河之间往返时间最多也就 2 天，如果一个星期都没有见到船夫，那基本上就可以确定是翻船了.

但是，等待也是有成本的，因为如果当前在运的这件货物还没处理好，后面的货物就会挤压，没法及时运出去，会造成经济损失，所以甲就要想办法在尽可能较短的时间内识别出翻船的情况，然后再叫一个船夫过来重新发包. 那么甲可以设定一个等待时间，比如说 3 天，如果等了 3 天还没见到船夫，马上重传.

状态如下

**A 村的甲**

1. 等待来自小镇的货物，打包并标记 0 号包裹，给船夫发送
2. 启动计时器，等待 ACK(0) 纸条，如果在计时器结束前收到 ACK(1) 或模糊不清的纸条， 或者在一个计时段内什么都没收到，就重传 (跳到 1)；如果收到，停止计时，跳到 3
3. 等待来自小镇的货物，打包并标记  1 号包裹，给船夫发送
4. 启动计时器，等待 ACK(1) 纸条，如果在计时器结束前收到 ACK(0) 或模糊不清的纸条，或者在一个计时段内什么都没收到，就重传 (跳到 3)；如果收到，停止计时，跳到 1

**B 村的乙**

1. 希望收到 0 号包裹，等船夫运货过来，检查编号，如果编号正确且无损坏，写纸条 ACK(0) 让船夫送回去，跳到 2；否则写 ACK(1) 让船夫送回去，继续等待
2. 希望收到 1 号包裹，等船夫运货过来，检查编号，如果编号正确且无损坏，写纸条 ACK(1) 让船夫送回去，跳到 1；否则写 ACK(0) 让船夫送回去，继续等待