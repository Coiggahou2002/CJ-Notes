# 查找 | 散列查找

![](https://cjpark-1304138896.cos.ap-guangzhou.myqcloud.com/note_img/20211017103634.png)

## Pre. 基本概念

**同义词**：如果 $H(x)=H(y)$ 则 $x$ 和 $y$  是同义词.

**装填因子**：$\alpha = n/m$，其中 $n$ 是表中记录数，$m$ 是散列表长度. 装填因子越大，表示哈希表越满，发生冲突的可能性越大.

## 1. 哈希函数

### 1.1 直接定址法

$$
H(x)=ax+b
$$

直接用一次函数映射，无冲突，适合 $key$ 连续分布的情况，若不连续容易浪费空间

### 1.2 除留余数法

$$
H(x)=x \mod p
$$

$p$ 取满足 $p\le m$ 的最大质数，取质数的好处是分布更均匀.

### 1.3 数字分析法

关键字 $key$ 可能在某几位上大家都差不多，在某几位上分布均匀（就是大家的这几位一般不一样）

比如电话号码 $138....0249$，前面几位大家都差不多，但是最后四位基本都不一样.

可以直接取最后四位作散列地址，这样地址范围就是 $0-9999$，给一个长度 $10000$ 的哈希表就不会冲突了.

**数字分析法适用于对 $key$ 集合的大致特征已经有所了解的情况.**

### 1.4 平方取中法

将 $key$ 平方之后，取这串数字最中间的几位数字.

如 $12318^{2}=151733124$，可以取 $7331$ 作为散列地址.

## 2. 处理冲突的方法

### 2.1 开放定址法

#### 2.1.1 线性探测法

道理很简单：如果坑被人占了，就顺着这个坑往后找，一个一个找，找到空的就占.

例如，$H(x)=i$，即 $x$ 先把第 $i$  个空位占了，然后又有 $H(y)=i$，此时 $y$  发现正确的坑被 $x$ 占了，就依次往后看，如果 $i+1$ 是空的就占它，否则再看 $i+2$，以此类推，直到找到空的坑位.

（如果一直找到最后都没坑位，再从 0 号坑位开始看）

#### 2.1.2 平方探测法

玄学。我也不懂。

缺点是不能探测到所有单元，但至少能探测到一半单元.

#### 2.1.3 双散列法

玄学。我也不懂。

### 2.2 拉链法

哈希表的每个位置放一个链表，如果发生哈希冲突，即 $H(x)=H(y)=\lambda$，则将 $x,y$ 都挂到第 $\lambda$ 个链表上（可以头插法也可以尾插法）

## 3. 性能分析

### 3.1 散列表查找效率

依赖于三个因素：

+ 散列函数
+ 处理冲突的方法
+ 装填因子

### 3.2 平均查找长度计算

哈希表的平均查找长度依赖于装填因子 $\alpha$，不直接依赖于表项数 $n$ 或表的长度 $m$.

#### 3.2.1 **线性探测法的 ASL 计算套路**

**查找成功：**

+ 先按照题意将哈希表构造出来
  + 按照规则，先根据 $key$ 计算 $H(key)$
  + $H(key)$ 位置有坑就占，没坑就顺着往下找
  + 在这个过程中，要标记那些位置“不正统”的元素，还要标记它们的“正统位置”
+ 对每个元素 $x$ ，将它现在所处的位置与它本应处的位置相减，得到一个偏移量 $\delta(x)$，比如说，$H(2733)=4$，但是 $4$  和 $5$ 的位置被占了，只能占 $6$，那么 $\delta(2733)=6-4=2$
+ 对于表中的每个元素 $x$ 来讲
  + 如果它就处在 $H(x)$ 位置，那么找到他需要花费 1 个查找长度
  + 如果它不处在 $H(x)$ 位置，则找到他需要花费 $\delta(x)+1$ 个查找长度
+ 最后，将每个元素的查找长度加起来，除以元素总个数，就得到成功查找的 $ASL$

$$
ASL_{success}=\frac{\sum(\delta_{i}(x)+1)}{n}
$$

**查找失败：**

首先要明白，查找失败的计算方法和查找成功有很大不同！

因为我们处理冲突的方式是线性探测法，所以，一个令人匪夷所思的情况就是，当你要找一个元素 $x$ 的时候，它有可能在 $H(x)$ 或者 $H(x)$ 后面的第若干个位置（因为你之前也许有很多冲突元素占掉了一大排位置），但你又不知道具体到底在哪里，只能按顺序一个个看.

现在我们假定这个 $x$ 它不在表中，但你并不知道这件事.

于是你老老实实地从 $H(x)$ 开始往后找，一直找啊找....

你找不到啊！但是你不肯死心啊！对不？

你想：万一这个表在生成的时候， $H(x)$ 有很多很多冲突，它的后面跟着很长一排冲突元素，对吧

你一直找啊找...什么时候可以死心呢？

碰见空位置你就可以死心了！哈哈哈哈哈！

为啥？因为一旦出现空位置，说明你要找的元素不在 $H(x)$ 的“尾随冲突列表”中，对不对？

Bingo！

具体计算步骤如下：

+ 先按照题意将哈希表构造出来
  + 按照规则，先根据 $key$ 计算 $H(key)$
  + $H(key)$ 位置有坑就占，没坑就顺着往下找
  + 在这个过程中，要标记那些位置“不正统”的元素，还要标记它们的“正统位置”
+ 对于表中每个有效位置 $p_i$
  + 什么是有效位置？其实就是 $H(x)$ 的值域，比如说你的哈希函数是 $x\mod7$，那你的有效位置范围只能是 $0-6$.
  + 数一数，从 $p_i$ 开始，一直找到空位置，需要走多少个格子？比如 $HT[0]=98$，一直到$HT[8]$ 才是空位置，那么对于你给出的每个注定查找失败的、$H(x)=0$ 的元素 $x$，我都必须走 9 个长度才能确定我是查找失败的（才能死心）.
  + 如果我们把 $p_i$ 的格子数记作 $\Delta_i$，有效位置的个数记作 $n$  ， 那么公式就是：

$$
ASL_{failed}=\frac{\sum\Delta_i}{n}
$$

**总结：**

查找成功的 $ASL$ 要针对每个**元素**来计算

查找失败的 $ASL$ 要针对每个**有效哈希位置**来计算

### 3.2.2 拉链法的 ASL 计算套路

**查找成功：**

+ 先按题意构造哈希表，记得把链表结构画完整，包括结尾的空指针
+ 挂在众多链表的第 $i$ 层的元素，查找到它们都需要花费 $i$ 个查找长度
+ 如果把每个元素所处链表的层数记作 $p_i$，元素总个数记作 $n$，那么

$$
ASL_{success}=\frac{\sum p_i}{n}
$$

**查找失败：**

+ 先按题意构造哈希表，记得把链表结构画完整，包括结尾的空指针
+ 对于每个有效查找位置，查找失败的长度是它所挂的链表长度 + 1
  + **为什么要加 1 ？因为你要找到链表结尾的空指针，才知道这一条链表结束了**
+ 如果把每个有效查找位置的链表长度记作 $L_i$，有效查找位置个数记作 $n$，那么

$$
ASL_{failed}=\frac{\sum(L_i+1)}{n}
$$