# 查找 | 基本理论知识

## 一、基本概念

**查找表**：在其上执行查找操作的那个数据结构

**静态查找表**：只查不改

**动态查找表**：增删改查

**关键字(key)**：用于唯一标识元素

**平均查找长度(Average Search Length)**：查找过程中关键字比较次数平均值

$$
ASL=\sum_{i=1}^{n}P_iC_i
$$

一般来讲，认为 $P_i=\frac{1}{n}$，即每个元素被查找的概率相等，$C_i$ 为找到需要的比较次数.



## 二、顺序查找

### 普通线性表

$$
ASL_{succeed}=\sum_{i=1}^{n}\frac{i}{n}=\frac{n+1}{2}
$$

$$
ASL_{failed}=n+1
$$

### 有序表

$$
ASL_{failed}=\frac{1+2+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$

假设待查找有序序列共有 $n$ 个节点，就有 $n+1$ 个失败区间. 若查找失败，则要找的元素必然会落到某个失败区间中，假设查找失败落到这些区间的概率相等，都是 $\frac{1}{n+1}$，这就是上面式子的分母.

分子里面有两个 $n$ 是因为最后一个成功节点的左右两端各有一个失败区间，落到这两个失败区间需要的比较次数都是 $n$（因为都需要走到最后一个成功节点并且和成功节点匹配失败）.

### 比较

假若都执行顺序查找，有序表相比普通线性表，能够通过“失败区间”提前感知到失败并提前结束，所以，就 $ASL_{failed}$ 来讲，有序表小于线性表.

但若是查找成功的情况，两者的 $ASL_{succeed}$ 是相同的，因为查找成功只有那个节点的位置有关，跟失败区间是没有关系的，那么有序表在这方面也没有优势.



## 三、折半查找

### 条件

查找表必须是支持随机访问的线性表，且必须有序

### 重要性质

**1.折半查找的判定树是平衡二叉树（任意节点左右子树深度差不超过 1 ）**

如果使用左偏法取中点，即 $\lfloor(l+r)/2\rfloor$，那任意节点的右子树节点数必然比左子树节点数多 0 或者多 1；

如果使用右偏法取中点，即 $\lceil(l+r)/2\rceil$ ，则与上面相反.

**2.若有序序列有 $n$ 个元素，则**

+ 对应判定树有 $n$ 个成功节点与 $n+1$ 个失败节点
+ 树高 $h=\lceil\log_2 (n+1)\rceil$，注意，该树高默认不包含失败节点

**3.查找一个不存在的元素，比较次数最多为 $h$，最少为 $h-1$**

**4.成功和失败的 $ASL$ 计算方法**

$$
ASL_{succeed}=\frac{\sum每层成功节点数×所在层数}{成功节点总数}
$$

$$
ASL_{failed}=\frac{\sum每层失败节点数×(所在层数-1)}{失败节点总数}
$$

**5.判定树的画法**

+ 先确定中点取法，左偏还是右偏
+ 根据具体左/右偏，自顶向下划分序列
+ 记得要画出失败节点（正方形）

### 与二叉搜索树的比较

折半查找的必然生成平衡二叉树，而二叉搜索树只有最好情况下才是平衡的，最坏情况下可能退化为链表状的单支树，所以两者时间性能不一定相同.



## 四、分块查找

### 性质

**1.块内允许无序，块间有序**

**2.对各个块建立索引表，每个索引项存该块的下标范围与块内最大(或最小)元素**

**3.如果查索引和查块都用顺序查找，则**

$$
ASL=\frac{1}{2}(s+\frac{s}{n})+1\ge \sqrt{n}+1
$$

当且仅当块长 $s=\sqrt{n}$ 时取最小值.

**4.如果需要查找速度尽可能快，则索引和块都使用折半查找**