## 剑指 Offer 50. 第一个只出现一次的字符

https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/

首先的首先，这题至少 $O(n)$ 完整遍历一遍，因为但凡没有遍历到最后一个字符，你都无法完全掌握某个字符到底是不是出现了一次，所以不用考虑什么双指针之类的算法了.

第一次想得太复杂了，打算用哈希表存频率，然后又被“第一次”的顺序要求卡住了，不知道怎么办，毕竟这个 50000 的数据规模，绝对不可以使用 $O(n^2)$ 的算法，否则必然会炸，所以必须使用 $O(n)$ 或者最多 $O(n\log n)$ 的算法，从而必须用空间换时间. 所以就想着再开一个哈希表，用来存每个字符第一次出现的位置，这样，在遍历频率表找到频率为 1 的字符之后，就可以用第二个哈希表找到它第一次出现的位置，然后比较一波找到最小的出现位置字符，返回那个字符.

但是！实际上完全没有这么复杂！一开始让我卡住的是“第一次”这个顺序要求，也就是说，我有了频率表之后，缺失的是原字符串的顺序信息，但是！！！原字符串本身不就提供了这个信息吗？！

所以，跑一次字符串记录下频率表之后，再从头跑一次，一边跑一边从哈希表读频率，一旦读到 1 就返回，就可以了。

```cpp

class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char, int> freq;
        for (char ch : s) {
            freq[ch]++;
        }
        for (char ch : s) {
            if (freq[ch] == 1) {
                return ch;
            }
        }
        return ' ';
    }
};
```

